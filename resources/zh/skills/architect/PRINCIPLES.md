# 架构设计原则 - 详细参考

本文档是架构师技能的详细参考，包含约束性规范、标准定义、评估指南和示例。

---

## 1. 方案分级标准（Small/Medium/Large）

### Small Architecture（最小可行架构）

**适用场景**：
- MVP（最小可行产品）、原型验证
- 内部工具、小规模应用
- 快速验证商业模式

**技术特征**：
- 单体应用（Monolith）
- 单数据库（可能是SQLite/PostgreSQL）
- 简单部署（单服务器或小型云实例）
- 无需缓存层或消息队列
- 同步处理为主

**规模指标**：
- 用户数：< 1000
- TPS/QPS：< 100
- 数据量：< 10GB
- 并发连接：< 100

**优点**：
- 开发快速（1-2周上线）
- 架构简洁，易于理解
- 部署简单，运维成本低
- 适合快速迭代

**缺点**：
- 扩展性受限（垂直扩展为主）
- 单点故障风险
- 性能瓶颈明显
- 难以演进为复杂架构

**何时选择**：
- 用户明确要求"快速上线MVP"
- 业务模式未验证，需要快速试错
- 预估用户规模小（< 1000）
- 团队规模小（1-3人）

---

### Medium Architecture（平衡扩展架构）

**适用场景**：
- 成熟产品、稳定业务
- B2B企业服务、中等规模SaaS
- 需要一定扩展性但不追求极致性能

**技术特征**：
- 模块化单体或分层架构（Modular Monolith / Layered）
- 读写分离（主从数据库）
- 缓存层（Redis/Memcached）
- 异步处理（任务队列，如Celery/RabbitMQ）
- 分层部署（应用服务器、数据库服务器分离）
- 可能引入CDN、负载均衡

**规模指标**：
- 用户数：1,000 - 100,000
- TPS/QPS：100 - 10,000
- 数据量：10GB - 1TB
- 并发连接：100 - 10,000

**优点**：
- 架构优雅，职责清晰
- 性能平衡，成本可控
- 可扩展（水平扩展应用层，垂直扩展数据层）
- 便于后续演进为微服务

**缺点**：
- 复杂度中等，需要一定架构理解
- 运维成本增加（多服务器、缓存、队列）
- 部署流程较复杂

**何时选择**：
- 用户要求"平衡实用"
- 业务已验证，处于增长期
- 预估用户规模中等（1,000 - 100,000）
- 团队有一定架构能力（3-10人）

---

### Large Architecture（高吞吐高扩展架构）

**适用场景**：
- 大规模互联网应用
- 高并发场景（电商秒杀、社交网络）
- 需要高可用性（99.99%以上SLA）

**技术特征**：
- 微服务架构（Microservices）
- 分库分表（Sharding）
- 分布式缓存（Redis Cluster）
- 消息队列（Kafka/RabbitMQ）
- 服务网格（Service Mesh，如Istio）
- 异地多活、容灾备份
- 自动化运维（K8s、CI/CD）

**规模指标**：
- 用户数：> 100,000
- TPS/QPS：> 10,000
- 数据量：> 1TB
- 并发连接：> 10,000

**优点**：
- 高性能、高可用
- 弹性扩展（可按需扩缩容）
- 架构高度解耦、极致优雅
- 技术栈可异构（不同服务用不同语言）
- 易于演进和修改

**缺点**：
- 复杂度高，需要深厚架构功底
- 实施周期长（3-6个月）
- 运维成本高（需要专业运维团队）
- 开发成本高

**何时选择**：
- 用户明确"不在乎成本/时间，追求极致优雅"
- 业务规模大（> 100,000用户）
- 有极高可用性要求（金融、医疗等）
- 团队架构能力强（10+人，有微服务经验）

---

## 2. 强制原则详解

### 2.1 归一化（DRY在架构层）

**定义**：避免重复的子系统职责，相似功能模块必须合并为统一模块。

**检查点**：

✅ **多来源输入的归一化**：

**场景**：系统需要处理HTTP请求和WebSocket消息

| 做法 | 架构 | 问题/优点 |
|------|------|-----------|
| ❌ 错误 | HTTPHandler → 业务逻辑A，WebSocketHandler → 业务逻辑B | 业务逻辑重复 |
| ✅ 正确 | HTTPAdapter + WebSocketAdapter → 统一格式 → 业务逻辑层 | 业务逻辑只写一次 |

**正确架构的层次**：

| 层级 | 组件 | 职责 |
|------|------|------|
| 适配层 | HTTPAdapter | 将HTTP请求转换为统一格式 |
| 适配层 | WebSocketAdapter | 将WebSocket消息转换为统一格式 |
| 业务层 | BusinessLogic | 只处理统一格式的输入 |

✅ **相似功能模块的归一化**：

**场景**：系统有多个报表生成功能

| 做法 | 模块设计 | 问题/优点 |
|------|----------|-----------|
| ❌ 错误 | UserReportGenerator, OrderReportGenerator, InventoryReportGenerator 各自实现 | 查询、格式化、导出逻辑重复 |
| ✅ 正确 | ReportGenerator + DataSource接口 + Formatter接口 + Exporter接口 | 通过配置指定数据源/格式/导出方式 |

✅ **子系统职责的归一化**：

| 做法 | 服务划分 | 问题/优点 |
|------|----------|-----------|
| ❌ 错误 | AuthService + PermissionService + SessionService | 三个服务职责重叠 |
| ✅ 正确 | IdentityService（含认证+授权+会话管理） | 统一管理用户身份相关职责 |

**验证问题**：
1. 是否存在重复的子系统职责？
2. 多来源输入是否需要统一抽象层？
3. 相似功能模块是否应该合并？
4. 配置化能否消除重复逻辑？

---

### 2.2 YAGNI（You Aren't Gonna Need It - 不过度设计）

**定义**：不为未确定的需求设计，只实现当前需要的功能。

**检查点**：

✅ **只实现当前需求**：

**场景**：当前需求支持两种输入协议

| 做法 | 设计决策 | 结果 |
|------|----------|------|
| ✅ 符合YAGNI | 设计统一抽象层处理当前两种输入 | 满足需求，无冗余 |
| ❌ 违反YAGNI | 设计通用插件系统支持任意协议 | 过度设计 |
| ❌ 违反YAGNI | 添加配置文件动态加载协议处理器 | 过度设计 |

✅ **避免预测性设计**：

**场景**：当前需求是单租户系统

| 做法 | 设计决策 | 结果 |
|------|----------|------|
| ✅ 符合YAGNI | 按单租户设计，未来需要再重构 | 满足当前需求 |
| ❌ 违反YAGNI | 现在就设计多租户数据隔离 | 过度设计 |
| ❌ 违反YAGNI | 添加tenant_id字段"以防万一" | 过度设计 |

**归一化 vs YAGNI的平衡**：

| 原则 | 关注点 | 适用场景 |
|------|--------|----------|
| 归一化 | 消除**当前存在的重复** | 发现多处相似逻辑 |
| YAGNI | 不为**未来可能的需求**设计 | 考虑是否添加新功能 |

两者并不冲突：归一化消除当前重复，YAGNI避免未来预测

**验证问题**：
1. 设计的每个抽象层是否服务于当前需求？
2. 是否有"以防万一"的预留设计？
3. 是否为未确定的需求添加了灵活性？

---

### 2.3 SOLID原则

#### SRP（Single Responsibility Principle - 单一职责原则）

**定义**：每个类/模块只负责一件事。

**架构层的SRP**：

| 做法 | 服务设计 | 结果 |
|------|----------|------|
| ✅ 正确 | UserService（用户CRUD）、AuthService（认证授权）、NotificationService（通知） | 职责清晰 |
| ❌ 错误 | UserService同时负责用户CRUD+认证+邮件+报表 | 职责混乱 |

#### OCP（Open-Closed Principle - 开闭原则）

**定义**：对扩展开放，对修改关闭。

**架构层的OCP**：

| 做法 | 扩展方式 | 结果 |
|------|----------|------|
| ✅ 正确 | 定义PaymentStrategy接口，新增支付方式时添加新Strategy | 不修改核心代码 |
| ❌ 错误 | PaymentService内部if/else判断支付方式 | 每次新增都要修改核心代码 |

#### DIP（Dependency Inversion Principle - 依赖反转原则）

**定义**：高层模块不依赖低层模块，都应依赖抽象。

**架构层的DIP**：

| 层级 | 正确做法 | 错误做法 |
|------|----------|----------|
| 应用层 | 依赖Repository接口（抽象） | 直接依赖具体数据库实现 |
| 基础设施层 | 实现Repository接口 | - |

**DIP的优点**：可切换数据库实现

---

## 3. NFR评估指南（按项目类型）

### 3.1 后端服务专属

**评估维度**：

1. **吞吐量需求**：
   - 预估TPS/QPS
   - 是否需要异步处理（任务队列）
   - 是否需要消息队列（Kafka/RabbitMQ）

2. **并发需求**：
   - 预估并发连接数
   - 是否需要连接池
   - 是否需要限流、熔断（防止雪崩）

3. **数据量**：
   - 预估数据量级
   - 是否需要分库分表
   - 是否需要数据归档

4. **读写比例**：
   - 读多写少 → 读写分离、CQRS
   - 写多读少 → 优化写入性能

5. **SLA要求**：
   - 可用性目标（99.9% / 99.99%）
   - 是否需要异地多活
   - 是否需要故障自动切换

6. **水平扩展**：
   - 是否需要无状态服务
   - 是否需要负载均衡

---

### 3.2 前端应用专属

**评估维度**：

1. **首屏加载**：
   - 是否需要代码分割（Code Splitting）
   - 是否需要懒加载（Lazy Loading）
   - 是否需要SSR（Server-Side Rendering）

2. **用户体验**：
   - 是否需要响应式设计（适配多屏幕）
   - 是否需要无障碍访问（Accessibility）

3. **离线能力**：
   - 是否需要PWA（Progressive Web App）
   - 是否需要本地缓存（IndexedDB/LocalStorage）

4. **跨平台**：
   - Web vs 移动原生 vs 混合（Hybrid）vs 桌面（Electron）

---

### 3.3 通用架构评估（所有项目必评）

**必须评估的维度**：

1. **架构优雅度**：
   - 模块边界是否清晰
   - 职责是否单一
   - 是否符合归一化、YAGNI、SOLID

2. **可维护性**：
   - 代码是否易于理解
   - 模块是否易于修改

3. **可扩展性**：
   - 是否支持插件机制
   - 是否支持配置化
   - 是否遵守开闭原则

4. **安全性**：
   - 认证授权机制
   - 数据加密（传输加密、存储加密）
   - 输入验证（防止SQL注入、XSS）

---

## 4. 架构模式选择指南

### 4.1 分层架构（Layered Architecture）

**适用场景**：
- 大多数业务应用
- 需要清晰分层和职责分离

**分层示例**：
```
Domain Layer（领域层）
├── 业务实体（Entity）
├── 业务规则（Business Logic）
└── 领域服务（Domain Service）

Application Layer（应用层）
├── 用例（Use Case）
├── 应用服务（Application Service）
└── DTO（数据传输对象）

Infrastructure Layer（基础设施层）
├── 数据库访问（Repository实现）
├── 外部API调用
└── 消息队列、缓存等
```

---

### 4.2 事件驱动架构（Event-Driven Architecture）

**适用场景**：
- 异步处理、高并发
- 需要解耦的模块间通信
- 需要事件溯源（Event Sourcing）

**示例**：
```
用户注册流程（事件驱动）：

1. UserService发布事件：UserRegistered
2. 订阅者自动处理：
   - EmailService → 发送欢迎邮件
   - AnalyticsService → 记录用户注册事件
   - NotificationService → 推送通知

优点：各服务解耦，新增订阅者不影响UserService
```

---

### 4.3 CQRS（命令查询职责分离）

**适用场景**：
- 读写分离
- 复杂查询场景

**示例**：
```
Command Side（写侧）：
- 处理用户操作（创建、更新、删除）
- 写入主数据库
- 发布事件

Query Side（读侧）：
- 处理查询请求
- 读取从数据库或物化视图
- 优化查询性能
```

---

### 4.4 微服务架构（Microservices）

**适用场景**：
- 大规模应用
- 需要独立部署、技术异构
- 团队规模大（> 10人）

**注意事项**：
- 需要服务发现、配置中心
- 需要分布式追踪
- 需要API网关
- 运维复杂度高

---

## 5. 好的架构 vs 坏的架构

### 好的架构特征

✅ **模块边界清晰**：
- 每个模块职责单一
- 模块间依赖单向（高层 → 低层）
- 无跨层依赖泄漏

✅ **归一化彻底**：
- 无重复的子系统职责
- 多来源输入通过统一抽象层
- 相似功能模块已合并

✅ **符合YAGNI**：
- 只实现当前需求
- 无"以防万一"的预留设计

✅ **事件流清晰**：
- 数据流和事件流可追踪
- 易于理解和调试

---

### 坏的架构特征

❌ **模块边界模糊**：
- 职责重叠
- 循环依赖
- 跨层依赖泄漏

❌ **重复职责**：
- 相似逻辑在多处实现
- 多来源输入分别处理

❌ **过度设计**：
- 为未来需求预留扩展
- 过度抽象、过度灵活

❌ **含糊架构**：
- 只有组件列表，无协作逻辑
- 事件流和数据流不清晰

---

## 6. 推荐阅读

- Martin Fowler - 《企业应用架构模式》
- Eric Evans - 《领域驱动设计》
- Sam Newman - 《微服务设计》
- Uncle Bob - 《架构整洁之道》
