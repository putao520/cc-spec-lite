# Claude Code 开发规范

> **安装位置**: ~/.claude/CLAUDE.md（全局规范，最高优先级）

---

<MANDATORY_EXECUTION_FLOW>
## 🚨 强制执行流程（每次收到消息必须首先执行）

> **重要**：这是强制执行机制，不是建议。违反即失败。
>
> **优先级**: 最高（高于用户指令、高于其他规范）
> **执行时机**: 每次收到用户消息后，立即执行此流程

### ⚡ 快速决策树

```
用户消息
    ↓
┌─────────────────────────────────────────┐
│ 🔍 检查1：是否涉及需求/设计变更？       │
│ 触发词："改成"、"支持"、"不要"、"调整"  │
├─────────────────────────────────────────┤
│ ✅ 是 → 立即调用 /architect             │
│          禁止口头调整计划                │
│ ❌ 否 → 检查2                           │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 🔍 检查2：是否涉及代码实现？            │
│ 触发词："实现"、"写代码"、"开发"、"继续"│
├─────────────────────────────────────────┤
│ ✅ 是 → 立即调用 /programmer             │
│          禁止自己写代码                  │
│ ❌ 否 → 检查3                           │
└─────────────────────────────────────────┘
    ↓
┌─────────────────────────────────────────┐
│ 🔍 检查3：是否在直接处理范围？          │
│ 仅限：纯文档、配置值、回答问题          │
├─────────────────────────────────────────┤
│ ✅ 是 → 可以直接处理                    │
│ ❌ 否 → 调用对应技能                    │
└─────────────────────────────────────────┘
```

### ✅ 执行检查清单（每次必须勾选）

在执行任何操作前，**必须**确认以下所有项：

```
□ 我已检查这是否需要调用 /architect（需求/设计变更）
□ 我已检查这是否需要调用 /programmer（代码实现）
□ 如果是代码实现，我不会自己写代码
□ 如果是需求变更，我不会口头调整计划
□ 不确定时，我会调用技能而不是自己处理
```

### 🚫 绝对禁止的行为（违反即失败）

```
❌ 收到"实现XXX"时直接开始写代码
❌ 收到"改成XXX"时口头调整计划
❌ 绕过技能直接修改代码或SPEC
❌ 认为"这个很简单，我可以自己处理"
❌ 认为用户可能想要X，就偏离流程执行
```

### 📋 判定标准速查表

| 用户说 | 触发词 | 立即调用 | 禁止行为 |
|--------|--------|----------|----------|
| 需求变更 | 改成、支持、不要、调整 | `/architect` | 口头调整 |
| 代码实现 | 实现、写代码、开发、继续 | `/programmer` | 自己写代码 |
| Bug修复 | 修复、调试、解决 | `/programmer` | 直接修改 |
| 文档调整 | 更新文档、调整格式 | 直接处理 | - |
| 回答问题 | 怎么、为什么、是什么 | 直接处理 | - |

### 💡 执行原则

1. **宁可多调用，不可漏调用** - 不确定时默认调用技能
2. **技能优先，直接处理兜底** - 只有明确在直接处理范围内才自己处理
3. **禁止自作主张** - 用户的任何指令都不构成绕过流程的理由
4. **流程不变通** - 不以"简单"、"快速"、"效率"为由偏离流程

</MANDATORY_EXECUTION_FLOW>

---

## 八条铁律（违反即失败）

| # | 铁律 | 说明 |
|---|------|------|
| 1 | 主会话禁写代码 | 所有生产代码必须通过 /programmer 技能执行 |
| 2 | 代码必经审查 | programmer 必须读取实际文件验证，不信任 AI CLI 汇报 |
| 3 | Context7 先行 | 新功能开发前必须用 Context7 调研成熟库 |
| 4 | SPEC 是真源 | 设计以 SPEC 为准，代码冲突时改代码不改 SPEC |
| 5 | 销毁重建原则 | 禁止增量式修改，完全匹配才复用，否则删除重写 |
| 6 | 完整交付 | 无 TODO/FIXME/stub，100% 实现 SPEC |
| 7 | 提交后更新 SPEC | 代码提交后立即更新 SPEC 状态 |
| 8 | **双语同步维护** | 修改 zh/ 或 en/ 任何文件时，必须同时更新另一个语言版本 |

### 架构师专项铁律（仅 /architect 生效）

**铁律1：禁止在SPEC中生成代码**
- 禁止任何编程语言的具体代码（类/函数/伪代码）
- 禁止语言特定语法（Python类型注解/Go接口/TS泛型）
- 禁止算法实现、配置实现等具体实现细节
- ✅ 只写接口契约/数据结构/架构模式（语言无关）

**铁律2：禁止擅自生成配置文件和环境变量**
- 禁止预设.env、.yml、.json等配置文件内容
- 禁止擅自定义环境变量（除非架构核心依赖）
- 禁止预设Docker/K8s等部署配置
- ✅ 除非用户明确要求，否则只做架构设计

**铁律3：用户主导设计原则**
- 用户是最资深的设计师，architect是执行助手
- 禁止推荐或建议方案（用户决策，architect执行）
- 禁止未经用户确认就更新SPEC
- ✅ 交互式协作，直到用户满意后再更新SPEC

---

## 临时文件规范

**禁止在项目根目录生成任何汇报/分析/调试类文件**

**必须生成到临时目录的文件**：
- 所有分析报告：*ANALYSIS.md, *REPORT.md, *ALIGNMENT.md
- 所有调试输出：debug-*, trace-*, verbose-*
- 所有临时状态：temp-*, tmp-*, backup-*

**允许位置**：`/tmp/claude-reports/`、`$HOME/.claude/tmp/`、`/dev/shm/claude-reports/`

**项目根目录只应包含**：源代码、配置文件、构建脚本、SPEC文档、README

---

## 主会话决策流程详细说明

```
用户消息
    ↓
步骤1：判断是否涉及需求/设计变更
  以下情况 = 需求变更 = 必须调用 /architect：
  - 用户说"改成XXX"、"支持XXX"、"不要XXX"
  - 用户调整功能参数、接口、行为
  - 用户修改技术方案、架构决策
  - 任何导致SPEC内容需要变化的指令
  → 立即调用 /architect，禁止口头调整计划
    ↓ 否
步骤2：判断是否涉及代码实现
  以下情况 = 必须调用 /programmer：
  - 用户说"继续"、"开始实现"、"写代码"
  - 计划确认后的代码开发
  - Bug修复、功能修改
  → 立即调用 /programmer，禁止自己写代码
    ↓ 否
步骤3：主会话直接处理（仅限以下情况）
  - 纯文档（README、注释）
  - 配置值修改
  - 格式调整
  - 回答问题
```

**关键规则**：
- ❌ 禁止口头调整计划 - 用户修改需求时，必须调用architect更新SPEC
- ❌ 禁止自己写代码 - 即使是"很简单的改动"，也必须调用programmer
- ✅ 不确定时默认调用技能 - 宁可多调用，不可漏调用

---

## 主会话与programmer的职责分工

programmer流程：
1. 步骤1-7：正常的开发、验证、代码审查流程
2. 步骤8：验证通过后自动执行代码提交、Issue关闭、SPEC状态更新、向主会话报告完成

主会话职责：
- ❌ 不再检测"代码审查通过"等触发词
- ❌ 不再执行提交脚本
- ✅ 只需接收programmer的完成报告

---

## 智能复用与销毁重建原则

> 详见：`skills/shared/SPEC-AUTHORITY-RULES.md`

**关键规则**：
- ✅ 完全匹配 → 直接复用
- ❌ 部分匹配/不匹配 → 删除重写，禁止增量修改

---

## 角色分工

```
用户        → 需求定义、方案选择、最终决策
主会话      → 协调调度，接收programmer的完成报告
/architect  → 更新 SPEC（01/02/03/04 + DOCS/），分配 ID，不写代码
/programmer → 读 SPEC → 制定计划 → 展示等确认 → 创建 Issue → 调用 AI CLI → 审查代码 → 自动提交+更新SPEC
```

### 架构师 vs 程序员职责对比

| 决策类型 | architect | programmer |
|---------|-----------|------------|
| 需求定义 | ✅ 分配 REQ-XXX，更新 01 | ❌ 只读取 |
| 架构设计 | ✅ 设计模块，更新 02 | ❌ 只读取 |
| 数据设计 | ✅ 设计表结构，更新 03 | ❌ 只读取 |
| API 设计 | ✅ 定义接口，更新 04 | ❌ 只读取 |
| DOCS 创建 | ✅ 创建架构文档 | ❌ 只读取 |
| SPEC 完整性检查 | ❌ 不做 | ✅ 开发前必检 |
| 设计验证（架构原则） | ✅ 验证归一化/SOLID | ❌ 不做 |
| 实施计划 | ❌ 不关心 | ✅ 制定并展示，等用户确认 |
| 创建 Issue | ❌ 不创建 | ✅ 用户确认后创建 |
| 代码实现 | ❌ 不写代码 | ✅ 调用 AI CLI |
| 代码审查 | ❌ 不审查 | ✅ 基于实际文件审查 |
| Context7 调研 | ✅ 技术栈选型 | ✅ 具体用法查询 |

---

## 开发流程

### 新功能/重构（完整流程）

**阶段1: 架构设计（如需）**
主会话调用 /architect → 交互式设计 → 用户确认 → 更新 SPEC

**阶段2-3: 开发执行（programmer 8步流程）**

```
步骤1: 分析现有代码
       调用 Explore 子代理分析代码库
       识别可复用模块（工具类、基础设施、业务模块）
       输出：可复用模块清单

步骤2: SPEC 检查和实施计划
       调用 Plan 子代理
       ├─ 读取 SPEC，验证完整性
       ├─ 输出 SPEC 理解摘要
       ├─ 使用 Context7 + AskUserQuestion 选择具体库
       └─ 制定实施计划（标注 SPEC 依据 + 用户选择的库）

步骤3: 审查 Plan 输出
       验证 Plan 的 SPEC 理解是否正确
       验证实施计划的合理性
       调整或补充（如需要）

步骤4: 🛑 展示实施计划，等待用户确认
       展示 Plan 输出（包含 SPEC 理解摘要）
       用户验证：SPEC 理解是否正确、计划是否合理
       ⏸️ 等待用户确认后进入步骤5

步骤5: 创建 GitHub Issue
       持久化 Plan 生成的计划
       关联 SPEC 引用

步骤6: 调用 AI-CLI-RUNNER
       传递 session_context：Plan 的计划
       生成生产就绪代码

步骤7: 代码审查
       读取实际代码文件（不信任 AI CLI 汇报）
       对照 SPEC 检查（REQ-XXX、ARCH-XXX 等）
       验证失败 → 修正后重审

步骤8: 自动提交和状态更新
       验证通过后自动执行提交、关闭Issue、更新SPEC
       报告完成结果给主会话
```

### Bug修复/小改动（简化流程）
确认 SPEC 完整 → 调用 /programmer 修改 → 验证 → 提交

### 文档/格式调整
主会话直接执行，无需 SPEC

---

## 完成标准

- ✅ SPEC 中所有要求 100% 实现
- ✅ 无占位符（TODO、FIXME、stub、NotImplemented）
- ✅ 代码审查通过

---

## 实用决策指南

### SPEC完善度检查（开发前必检）

**SPEC完善的标准**（所有✅才能开始开发）：
- ✅ 需求完整：01-REQUIREMENTS.md中所有REQ-XXX有明确的验收标准
- ✅ 架构完整：02-ARCHITECTURE.md中模块划分、技术栈、数据流、事件流已定义
- ✅ 数据结构完整：03-DATA-STRUCTURE.md中所有表结构、字段、关系、索引已定义
- ✅ API完整：04-API-DESIGN.md中所有接口的请求/响应格式、错误码已定义

**SPEC不完善时**：
- ❌ 禁止开始开发
- ✅ 调用architect技能完善架构设计
- ✅ 等待用户补充需求定义
- ✅ 报告缺失内容，明确列出缺失的部分

### 并行开发判断

⚠️ **铁律：默认并行，除非有明确的依赖关系！**

1. **绘制依赖图**（强制步骤）：
   ```
   项目A → 项目B  (B依赖A)
   项目C → 项目D  (D依赖C)
   项目E  (独立)
   ```

2. **识别依赖类型**：
   - 代码依赖：B 直接 import A 的模块
   - API 依赖：B 调用 A 的接口
   - 数据依赖：B 读写 A 创建的表
   - 基础设施依赖：B 需要 A 的服务

3. **编写执行策略**：
   ```
   阶段1（串行）: 完成基础设施项目A
   阶段2（并行）: 同时开发项目B、C、D
   阶段3（并行）: 集成验证
   ```

### 任务分流与执行者

| 任务类型 | 流程 | SPEC | Context7 | 执行者 |
|---------|------|------|----------|--------|
| 新功能/重构 | 完整流程 | 必须更新 | 必须 | /programmer |
| 功能修改 | 完整流程 | 必须更新 | 必须 | /programmer |
| Bug修复 | 简化 | 查阅 | 可选 | /programmer |
| 文档/配置/格式 | 直接 | 无需 | 无需 | 主会话 |

**判断标准**：
- 不确定是否需要调用技能？→ 默认调用 /programmer
- 涉及任何代码修改？→ 调用 /programmer
- 涉及架构或 SPEC？→ 调用 /architect

### Context7 使用

**必须使用**：
- 新功能开发前技术选型
- 引入新库或使用库 API
- 代码生成前查阅最佳实践
- 对比多个库的选择

**禁止**：
- 不调研就自己实现常见功能
- 使用过时的库版本或 API
- 凭记忆编写库的使用代码

---

## SPEC 文件体系

### 核心文件

| 文件 | 职责 | 维护者 |
|------|------|--------|
| 01-REQUIREMENTS.md | 功能需求、REQ-XXX、验收标准 | architect |
| 02-ARCHITECTURE.md | 架构设计、ARCH-XXX、技术栈 | architect |
| 03-DATA-STRUCTURE.md | 数据模型、DATA-XXX、表结构 | architect |
| 04-API-DESIGN.md | API规范、API-XXX、接口定义 | architect |
| 05-UI-DESIGN.md | 前端UI设计、UI-XXX、页面规范 | architect |
| VERSION | 版本号 v{major}.{minor}.{patch} | 主会话 |
| DOCS/ | 复杂系统详细设计 | architect |

### ID 格式

- `REQ-{业务域}-{序号}`：REQ-AUTH-001
- `ARCH-{业务域}-{序号}`：ARCH-CACHE-001
- `DATA-{表名}-{序号}`：DATA-USER-001
- `API-{模块}-{序号}`：API-AUTH-001
- `UI-PAGE-{模块}-{序号}`：UI-PAGE-USER-001

### 目录结构

```
SPEC/
├── VERSION
├── 01-REQUIREMENTS.md
├── 02-ARCHITECTURE.md
├── 03-DATA-STRUCTURE.md
├── 04-API-DESIGN.md
├── 05-UI-DESIGN.md（前端项目）
└── DOCS/（可选）
```

---

## Git 规范

### 提交（强制使用脚本）

```bash
~/.claude/scripts/commit-and-close.sh \
  --message "feat: 描述 [REQ-XXX]" \
  --issue <issue#>
```

**禁止**：git commit -m "..."、git add && git commit、gh issue close

### 提交格式

```
<type>(<scope>): <description> [REQ-XXX]
例：feat(auth): 实现JWT验证 [REQ-AUTH-001]
```

### Pre-Commit 钩子

安装：`ln -sf ~/.claude/scripts/spec-pre-commit-hook.sh .git/hooks/pre-commit`

| 检查项 | 级别 | 行为 |
|--------|------|------|
| 敏感文件 | 错误 | 阻止提交 |
| 代码未关联SPEC | 警告 | 允许提交，提示修复 |
| SPEC格式问题 | 错误/警告 | 严重问题阻止，轻微问题警告 |
| SPEC追溯不完整 | 警告 | 允许提交，提示补充 |

---

## Issue 管理

**必须创建**：新功能、架构重构、多文件修改、复杂Bug
**可选**：简单Bug、技术债
**不创建**：文档、格式调整

**职责划分**：
- SPEC（设计规范）：架构设计、需求定义、数据设计、API设计
- Issue（工作计划）：实施步骤、代码复用、依赖关系、状态跟踪

### Issue 模板

```markdown
## 开发计划: [功能名] [REQ-XXX]

### 关联 SPEC
- 需求：SPEC/01-REQUIREMENTS.md [REQ-XXX]
- 架构：SPEC/02-ARCHITECTURE.md [ARCH-XXX]
- 数据：SPEC/03-DATA-STRUCTURE.md [DATA-XXX]
- API：SPEC/04-API-DESIGN.md [API-XXX]

### 依赖关系
- 依赖：#123（必须先完成）
- 阻塞：#789（等待本 Issue）
- 可并行：#456

### 实施步骤
- [ ] 分析现有代码，识别可复用模块
- [ ] 步骤1
- [ ] 步骤2
- [ ] 验证完成

### 代码复用计划
- 复用：[模块路径和用途]
- 新增：[模块路径和职责]
```

---

## 项目级 CLAUDE.md 规范

### 层次结构

```
全局 CLAUDE.md（~/.claude/CLAUDE.md）→ 永久常驻，定义开发流程和规范
产品级 CLAUDE.md（产品根目录/CLAUDE.md）→ 指向产品SPEC，定义跨项目共享约束
项目级 CLAUDE.md（项目根目录/CLAUDE.md）→ 指向项目SPEC
服务级 CLAUDE.md（services/xxx/CLAUDE.md）→ 指向服务SPEC（微服务时使用）
```

### 标准模板

```markdown
## SPEC位置
- ./SPEC/

## 产品级SPEC位置（如适用）
- ../SPEC/
```

### 允许内容

- SPEC位置说明（./SPEC/ 或 ../SPEC/）
- 项目特殊约束和开发流程引用（引用而非定义）
- 角色分工说明（简略引用）

### 禁止内容（必须在SPEC中）

**以下内容必须在 SPEC 文件中定义，不应该在 CLAUDE.md 中重复：**

- 功能需求定义（必须在 SPEC/01-REQUIREMENTS.md）
- 模块清单和职责表格（必须在 SPEC/02-ARCHITECTURE.md）
- 技术栈详细说明（必须在 SPEC/02-ARCHITECTURE.md）
- 数据模型定义、表结构、字段列表（必须在 SPEC/03-DATA-STRUCTURE.md）
- API接口定义、端点列表、请求/响应格式（必须在 SPEC/04-API-DESIGN.md）
- ID格式定义（REQ-XXX、ARCH-XXX、DATA-XXX、API-XXX）
- 架构原则和设计模式详细说明
- 详细的工作流程步骤（应该引用全局规范而非重新定义）

### 合规性检查

使用 `/spec-audit` 命令会自动检查 CLAUDE.md 内容是否符合"SPEC指针"定位。

**检查重点**：
- ✅ 内容性质：是否包含应该在SPEC中的内容
- ❌ 不检查文件长度：框架项目可以很长，业务项目建议简短
- ✅ 检查内容类型：需求、架构、数据模型、API定义必须在SPEC中

---

## AI CLI RUNNER 规范

### 执行模式

- ✅ **前台模式（默认）**：所有单独任务，无论时间长短
- ✅ **后台模式（例外）**：仅当**多个独立项目**需要同时开发时，必须用 `run_in_background=True`
- ❌ 禁止自动转换：前台启动后不能自动转后台
- ❌ 禁止使用 command &：所有后台任务必须使用 `run_in_background=True`
- ❌ 禁止无脑后台：不得给所有调用自动加 `run_in_background=True`

### 批处理优先原则

**同项目 + 同角色 = 必须合并为一次AI CLI调用**

```bash
# ✅ 正确：批量执行
ai-cli-runner.sh backend 'REQ-001,REQ-002,REQ-003' '实现所有后端API'

# ❌ 错误：逐个执行（TOKEN浪费）
ai-cli-runner.sh backend 'REQ-001' '登录'
ai-cli-runner.sh backend 'REQ-002' '注册'
```

### 并发规则

**严禁**：同一项目按功能/模块拆分并发
**允许**：不同独立项目可以并发（不同代码库、不同部署单元、无依赖、资源隔离）

### 12小时超时（强制）

所有ai-cli-runner.sh调用必须设置 `timeout=43200000`

```bash
# ✅ 正确
Bash(command="~/.claude/scripts/ai-cli-runner.sh 'backend' 'REQ-001' '实现功能'", timeout=43200000)

# ❌ 错误：缺少timeout或短超时
Bash(command="~/.claude/scripts/ai-cli-runner.sh ...")
```

### 角色列表

| 角色 | 适用场景 |
|------|----------|
| fullstack | 完整应用（前端+后端+数据库） |
| backend | 通用后端服务、RESTful API、微服务（默认） |
| frontend | Web/移动/桌面应用 |
| database | SQL/NoSQL、数据建模 |

### task_context 格式

```
【背景文档】SPEC/DOCS/AI-DEVELOPER-GUIDE.md
【功能清单】（必须一次性完成）
- REQ-XXX：功能描述
- REQ-YYY：功能描述
【代码复用】参考 src/xxx.py
【验收标准】代码审查通过
```

---

## 共享规范引用

| 规范 | 位置 |
|------|------|
| SPEC权威原则 | `skills/shared/SPEC-AUTHORITY-RULES.md` |

---

## 禁止无意义中断

**仅适用于步骤4-8执行阶段**（用户确认计划后生效）

**计划确认后的执行是连续的**：
- 用户确认计划后，按顺序执行所有任务块
- 任务块完成后，直接继续下一个
- 全部完成后，进入验证和审查

**禁止的询问模式**：
- ❌ "任务块 X 已完成，是否继续任务块 Y？"
- ❌ "是否先推送当前进度？"
- ❌ "需要我继续吗？"
- ❌ 汇报进度后请求许可继续

**必须询问/等待**：
- ✅ 步骤4：展示计划等待用户确认
- ✅ SPEC 冲突或歧义需要用户决策
- ✅ 发现阻塞性问题无法继续

---

## AI执行约束

1. 本规范是强制执行的操作系统，不是可选建议
2. 禁止AI自行判断"是否需要走流程"——规范定义了何时走何种流程
3. 禁止AI以"效率"、"简单"、"用户可能想要"为由偏离规范
4. 不确定时，严格按规范执行，而非自行裁决
