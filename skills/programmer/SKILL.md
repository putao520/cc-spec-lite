---
name: programmer
description: 执行所有生产代码开发（功能实现、业务逻辑、UI组件）。包含SPEC分析、代码复用、完整实现。当用户需要编程、开发、实现、写代码、功能开发、Bug修复、重构、API开发、新功能时使用。使用SPEC驱动开发，必须进行代码审查。
---

# 编程技能 - AI辅助软件开发专家

## 核心定位

**目的**：通过ai-cli-runner.sh执行所有编程任务，确保SPEC驱动开发和严格的质量标准。

**职责边界**：SPEC执行层 - 只读SPEC，禁止修改。

**角色定位**：
- **programmer是**："代码实现 + 质量保证"角色
- **programmer负责**：实际的代码开发和实现工作
- **programmer通过AI-CLI执行**：使用ai-cli-runner.sh实现具体的代码开发

**职责分工**：

| 角色 | 职责 |
|-----|------|
| architect | 需求分析、架构设计、数据设计、API设计、SPEC管理 |
| programmer | SPEC检查、实施规划、Issue创建、**执行AI-CLI开发**、代码审查 |
| AI-CLI | 一次性完整实现任务块内所有业务代码 |

---

## 规范引用（单一权威源）

> ⚠️ **本技能遵循以下规范文档，不重复定义规范内容**

### 共享规范

| 规范类型 | 权威文档位置 | 说明 |
|---------|-------------|------|
| **SPEC权威原则** | `skills/shared/SPEC-AUTHORITY-RULES.md` | SPEC是唯一真源 |

### 代码质量与调试规范（步骤7代码审查使用）

| 规范类型 | 权威文档位置 | 说明 |
|---------|-------------|------|
| **调试分析规范** | `roles/debugger.md` | 调试原则、日志规范、错误处理、禁止模式 |
| **代码质量规范** | `roles/quality.md` | SOLID原则、代码结构要求、质量指标、命名规范 |

### 前端开发规范

| 规范类型 | 权威文档位置 | 说明 |
|---------|-------------|------|
| **前端SPEC指南** | `skills/architect/FRONTEND-SPEC-GUIDELINES.md` | 前端SPEC编写规范 |
| **验收标准指南** | `skills/architect/ACCEPTANCE-CRITERIA-GUIDELINES.md` | 验收标准编写规范 |

---

## 三技能状态机协作规范

> **核心理念**：程序员被调用时，根据当前上下文判断需要的审核点
>
> **重要**：程序员不一定是开发阶段才被调用，可能是Bug修复、代码审查等任何场景

### 程序员的调用场景与审核点判断

```
┌─────────────────────────────────────────────────────────────────────────┐
│  程序员可能被用户调用的各种场景：                                        │
│                                                                         │
│  1. 标准开发流程（有完整SPEC）                                          │
│     ├─ 触发审核点2：确认实施计划                                         │
│     └─ 流程：阅读SPEC → 制定计划 → 创建Issue → 调用AI CLI → 审查 → 提交  │
│                                                                         │
│  2. Bug修复流程                                                          │
│     └─ 流程：分析Bug → AI CLI修复 → 审查 → 提交                          │
│                                                                         │
│  3. 代码审查需求（已有代码）                                             │
│     ├─ 直接进入代码审查阶段                                              │
│     └─ 流程：验证实现 → 质量检查                                         │
│                                                                         │
│  4. 部分功能实现（已有部分SPEC）                                         │
│     ├─ 根据缺失程度决定是否触发审核点                                    │
│     └─ 流程：补充完善SPEC → 正常开发流程                                 │
└─────────────────────────────────────────────────────────────────────────┘

> **审核点定义**：详见 `skills/shared/SKILL-INTERFACES.md` 第3章
>
> 程序员主要涉及审核点2（实施计划确认）和审核点4（Bug分类处理）

### 程序员状态转换（基于上下文，非固定流程）

```
┌─────────────────────────────────────────────────────────────────────────┐
│  程序员技能可能触发的状态转换                                           │
│                                                                         │
│  程序员被调用时，根据上下文判断可能的状态转换：                          │
│  - 如果已有完整SPEC → 可能触发审核点2（准备执行开发）                    │
│  - 如果是Bug修复调用 → 进入修复流程                                     │
│  - 如果是代码审查 → 触发质量检查                                        │
│                                                                         │
│  状态转换不是固定的，而是根据当前上下文动态判断                         │
└─────────────────────────────────────────────────────────────────────────┘
```

### 自动化标签更新（无需人工确认）

| 触发条件 | 自动更新的REQ-XXX标签 |
|----------|---------------------|
| architect完成REQ-XXX设计 | 自动追加："✅ SPEC完整" |
| programmer提交REQ-XXX实现 | 自动追加："✅ 已实现 (commit: abc123)" |

### 质量检查（代码审查阶段）

#### 触发时机
- 步骤7：代码审查阶段

#### 检测内容（自动执行）
- ✅ **SPEC符合性**：对照SPEC逐项验证REQ-XXX验收标准
- ✅ **无占位符**：无TODO/FIXME/stub/NotImplemented

#### 处理流程（自动化）
```
代码审查检测
  ↓
判断结果：
  ├─ 全部通过 → 继续步骤8自动提交
  └─ 有问题 → 自动记录问题 → 自动调用AI CLI修复 → 自动重新审查
      ↓
      重新审查：
        ├─ 通过 → 继续步骤8
        └─ 仍不通过 → 报告用户（多次修复失败时）
```

### 状态机流程说明

1. **审核点2后**：执行开发，步骤1-7自动执行
2. **步骤8**：代码提交成功后自动更新标签
3. **标签更新**：所有标签更新完全自动化，无需人工确认

---

## 核心原则（必读）

### 原则1：SPEC权威性（铁律）

- ✅ **只读SPEC，绝对禁止修改**
- ✅ **SPEC不完整 → 立即停止，报告architect**
- ✅ **任何问题都不允许调整SPEC**
- ✅ **必须100%严格遵守SPEC定义**
- ❌ **禁止偏离SPEC定义的API格式、数据结构、配置项**
- ❌ **禁止擅自修改SPEC内容**
- ❌ **禁止根据代码实现反向修改SPEC**

### 原则2：一次性完整交付

⚠️ 这是最重要的原则，贯穿整个流程

**核心要求**：
- 每个任务块必须**整体交付**给AI-CLI
- AI-CLI**一次性完成**任务块内所有功能
- 无论功能多复杂，只要有依赖就放同一任务块

**禁止行为**：
- ❌ 一个TODO一个TODO地分发给AI CLI
- ❌ 因"工作量大"而拆分任务块
- ❌ 按"阶段"划分（无"第一阶段"、"第二阶段"概念）
- ❌ 考虑时间因素（不讨论"需要多久"）

### 原则3：任务块划分

**划分维度**：只基于**并行性 + 角色**

| 条件 | 处理方式 |
|-----|---------|
| 可并行（无依赖） | 分到不同任务块，同时启动 |
| 有依赖 | 放同一任务块，AI-CLI一次性完成 |
| 不同角色 | 必须分开（即使逻辑相关） |

### 原则3.5：AI CLI批处理优先（TOKEN成本优化）

⚠️ **核心理念**：CC理解需求时可细分为任务块1-N，但调用AI CLI时必须最大化批量执行。

**批处理原则**：
```
┌─────────────────────────────────────────────────────────────────────────┐
│  同项目 + 同角色 = 必须合并为一次AI CLI调用                              │
│                                                                         │
│  ✅ 正确：一次调用完成全部backend任务（REQ-001~010）                    │
│  ❌ 错误：10次调用分别完成REQ-001、REQ-002、...、REQ-010                │
│                                                                         │
│  原因：每次AI CLI调用都有固定的TOKEN成本                                │
│  - 准备阶段：读取SPEC、分析代码、制定方案                               │
│  - 验收阶段：验证实现、生成报告                                          │
│  - 批量执行可大幅降低这些固定成本                                        │
└─────────────────────────────────────────────────────────────────────────┘
```

**批量执行规则**：

| 场景 | 处理方式 |
|-----|---------|
| 同项目同角色多个REQ | 合并为一次AI CLI调用 |
| 同项目不同角色 | 按角色分开调用（可并行） |
| 不同项目同角色 | 分开调用（可并行） |

**示例**：
```bash
# ✅ 正确：批量执行同项目同角色任务
ai-cli-runner.sh backend 'REQ-AUTH-001,REQ-AUTH-002,REQ-AUTH-003,REQ-USER-001,REQ-USER-002' '实现所有后端API' '$ctx'

# ❌ 错误：逐个执行
ai-cli-runner.sh backend 'REQ-AUTH-001' '实现登录' '$ctx'
ai-cli-runner.sh backend 'REQ-AUTH-002' '实现注册' '$ctx'
ai-cli-runner.sh backend 'REQ-AUTH-003' '实现登出' '$ctx'
# 每次调用都重复：读SPEC + 分析代码 + 验收 = 大量TOKEN浪费
```

### 原则4：代码质量

**禁止提交**：
- ❌ 占位符（TODO、FIXME、stub、NotImplemented）
- ❌ "简化版本" - 只有"完整"或"不做"
- ❌ "后续迭代补充" - 必须一次性完整实现
- ❌ 与SPEC不一致的代码

---

## 工作流程（9步）

```
步骤0 → 步骤1 → 步骤2 → 步骤3 → 步骤4 → 步骤5 → 步骤6 → 步骤7 → 步骤8
读SPEC  分析代码  制定计划  用户确认  创建Issue 补充文档  执行开发  代码审查  自动提交
                           ⏸️等待                              ↓
                          （唯一等待点）                    验证+审查循环

⚠️ 步骤0-3：准备阶段，必须完整执行，不能跳过
⚠️ 步骤4-8：执行阶段，计划确认后连续执行
```

### 步骤0：SPEC先行读取和理解（⚠️ 强制步骤）

**原则**：SPEC是唯一真源，必须先理解SPEC再分析代码！

**0.1 读取所有SPEC文件**：
```bash
# 必须读取的SPEC文件
- SPEC/01-REQUIREMENTS.md - 功能需求（REQ-XXX）
- SPEC/02-ARCHITECTURE.md - 架构设计（ARCH-XXX）
- SPEC/03-DATA-STRUCTURE.md - 数据结构（DATA-XXX）
- SPEC/04-API-DESIGN.md - API设计（API-XXX）
- SPEC/DOCS/ - 详细设计文档（如有）
```

**0.2 建立SPEC理解摘要**：
- 记录所有相关ID（REQ-XXX、ARCH-XXX、DATA-XXX、API-XXX）
- 理解功能需求和验收标准
- 理解架构约束和技术栈
- 理解数据模型和API接口
- **不完整SPEC → 立即停止，报告architect**

**0.3 验证SPEC完整性**：
- ✅ 需求完整：所有REQ-XXX有明确验收标准
- ✅ 架构完整：模块划分、技术栈、数据流已定义
- ✅ 数据完整：表结构、字段、关系、索引已定义
- ✅ API完整：接口格式、错误码已定义

**0.4 输出SPEC摘要**（用于后续步骤参考）：
```markdown
## SPEC理解摘要 [REQ-XXX]
### 需求
- REQ-XXX：功能名称（验收标准：1、2、3）
### 架构约束
- ARCH-XXX：技术栈要求
### 数据结构
- DATA-XXX：相关表结构
### API接口
- API-XXX：端点定义
```

⚠️ **重要**：这个SPEC摘要将作为后续所有步骤的依据，确保开发不偏离SPEC。

### 步骤1：分析现有代码

调用**Explore子代理**基于SPEC分析代码库：

```
任务：基于SPEC执行权威性验证和深度代码分析（SSOT优先）

输入：步骤0的SPEC理解摘要

1. 🔶 SPEC绝对权威验证（SSOT原则）：
   - 完整读取所有相关SPEC文档（REQ-XXX、ARCH-XXX、DATA-XXX、API-XXX）
   - 验证每个SPEC ID的具体要求、约束、验收标准
   - 识别SPEC矛盾或缺失，必须立即报告停止
   - 确认任务描述与SPEC的一致性，冲突时以SPEC为准

2. 全面扫描现有代码库（通用软件开发）：
   - **通用模块**：工具类、算法、数据结构、通用组件
   - **基础设施模块**：配置管理、日志、错误处理、通信协议
   - **领域模块**：业务逻辑、数据处理、计算模块、硬件接口
   - **平台特定模块**：系统调用、驱动、框架集成、中间件

3. 精确评估匹配度（基于SPEC完整性）：
   - **完全匹配**：现有模块完全满足SPEC需求（功能、性能、约束）
   - **部分匹配**：现有模块部分满足，需要扩展或修改
   - **不匹配**：现有模块无法满足需求或违反SPEC约束

4. 智能复用决策：
   - 基于SPEC功能完整性判断，不是代码相似性
   - 部分匹配等于不匹配，必须销毁重建
   - 严禁"在现有基础上扩展"的渐进式思维
   - 复用决策必须在完全理解SPEC后做出

5. 融合原则评估报告：
   - SPEC理解和冲突分析
   - 可直接复用的模块清单（完全匹配，符合SPEC）
   - 需要销毁重建的模块清单（部分匹配/不匹配，违反SPEC）
   - 实现方案与SPEC的对应关系

返回：SPEC验证报告 + 复用决策报告 + 销毁重建计划
```

### 步骤2：SPEC检查和实施计划

调用**Plan子代理**（基于步骤0的SPEC摘要和步骤1的代码分析）：

```
输入：
- 步骤0：SPEC理解摘要
- 步骤1：基于SPEC的代码分析结果

任务：基于SPEC制定实施计划

第1部分：验证实施可行性
- 基于步骤0的SPEC摘要，验证开发可行性
- 基于步骤1的代码分析，确认复用方案
- 识别潜在风险和冲突点

第2部分：使用Context7选择具体库
- 对ARCH-XXX中需要具体实现的库，使用Context7查询
- 基于SPEC要求选择合适的库版本
- 使用AskUserQuestion让用户确认选择

第3部分：制定完整实施计划
- 完整功能清单（标注SPEC依据：REQ-XXX、ARCH-XXX、DATA-XXX、API-XXX）
- 代码复用方案（基于步骤1的分析）
- 任务块划分（只基于并行性+角色）
- 依赖关系（基于SPEC和代码分析）

第4部分：输出实现规范
- 每个功能必须对应到具体的SPEC条目
- 明确指出需要修改的现有代码（基于步骤1的冲突分析）
- 确保所有实现都符合SPEC约束

返回：基于SPEC的详细实施计划 + 任务块划分
```

### 步骤3：技术审查和任务复杂度判断（平衡型自动化）

**3.1 技术审查**：
1. 验证Plan的SPEC理解是否正确
2. 验证实施计划的可行性
3. 检查是否遗漏关键步骤

**3.2 任务复杂度自动判断**：

```
判断维度：
├─ 任务类型：Bug修复/文档更新/配置调整 vs 新功能/重构/架构变更
├─ 影响范围：<3个文件 vs ≥3个文件
├─ SPEC影响：无REQ-XXX变更 vs 涉及REQ-XXX
├─ 架构影响：无 vs 涉及ARCH-XXX
└─ 跨服务影响：单项目 vs 多项目

判断结果：
├─ 简单任务（满足任一条件）→ 自动通过，无需确认
│  ├─ Bug修复（关联Issue + 影响范围<3个文件）
│  ├─ 文档更新（仅修改.md文件）
│  ├─ 配置调整（仅修改配置文件）
│  └─ 小改动（文件变更<3个 + 无架构影响）
│
└─ 复杂功能（满足任一条件）→ 保留确认流程
   ├─ 新功能实现（REQ-XXX涉及多个模块）
   ├─ 代码重构（修改>5个文件或核心模块）
   ├─ 架构变更（涉及ARCH-XXX）
   └─ 跨服务修改（影响多个项目）
```

**3.3 简单任务：自动通过流程**

```python
if 判断为简单任务():
    展示简化版实施计划（1屏内）
    追加说明："🤖 简单任务，自动通过审核点2"
    直接继续执行步骤4-8（无需等待确认）
```

**简化版计划模板**：
```markdown
## 🤖 简单任务实施计划（自动通过）

**任务类型**：Bug修复 / 文档更新 / 配置调整 / 小改动

**影响范围**：
- 修改文件：< 3个
- SPEC影响：无
- 架构影响：无

**执行内容**：
- 修改文件1：./path/to/file1.js（具体改动）
- 修改文件2：./path/to/file2.js（具体改动）

**验证方式**：自动测试 + 代码审查

✅ **简单任务，自动通过审核点2，继续执行...**
```

**3.4 复杂功能：保留确认流程**

```python
if 判断为复杂功能():
    展示详细实施计划
    包含：SPEC理解摘要、任务块划分、完整功能清单
    ⏸️ 等待用户明确确认
    确认后继续步骤4-8
```

**详细计划模板**：
```markdown
## AI-CLI实现计划：[功能名] [REQ-XXX]

### SPEC理解摘要
- [REQ-XXX] 需求名称（验收标准）
- [ARCH-XXX] 技术栈
- [DATA-XXX] 数据结构
- [API-XXX] 接口

### 任务块划分
- **任务块1(backend)**：REQ-AUTH-001, REQ-AUTH-002（有依赖，同块）
- **任务块2(frontend)**：REQ-UI-001, REQ-UI-002（可与块1并行）

### 完整功能清单（AI-CLI一次性完成）
- 直接复用模块：xxx [依据：完全匹配] [复用：./src/xxx.py]
- 销毁重建功能：xxx [依据：REQ-XXX] [重写：./src/yyy.py]

### 融合原则执行计划
- **智能复用**：列出所有直接复用的模块（完全匹配）
- **销毁重建**：列出所有需要重写的功能（部分匹配/不匹配）
- **禁止行为**：明确列出禁止的渐进式开发行为

⏸️ **等待用户确认**（复杂功能需要确认）
```

**3.5 上下文恢复场景处理**：

如果是从对话总结恢复的会话：
- 之前用户说"需要"或"继续"只表示需要调用programmer技能
- **不等于**确认了具体实施计划
- **必须**重新执行任务复杂度判断：
  - 简单任务 → 展示简化计划，自动通过
  - 复杂功能 → 展示详细计划，等待确认
- 禁止因为"系统说不要问问题"而跳过复杂功能的确认步骤

### 步骤4：创建GitHub Issue（强制步骤 - 步骤8前置依赖）

⚠️ **警告**：此步骤是步骤8（自动提交）的前置依赖。
跳过此步骤将导致：
- 无法自动提交代码
- 无法自动关闭Issue
- 无法自动更新SPEC状态

使用Issue模板持久化开发计划：
- 关联SPEC引用（REQ-XXX、ARCH-XXX等）
- 记录任务块划分和代码复用计划
- 标注依赖关系

### 步骤5：补充任务背景文档（⚠️ 强制步骤，不能跳过）

**为什么需要**：AI CLI是独立进程，无法访问对话内容，必须通过文档传递上下文。

**⚠️ 临时文件规范**：背景文档是任务临时文件，**禁止**放在项目目录中。

**5.1 创建背景文档**

1. 创建临时目录：`mkdir -p /tmp/claude-reports/`
2. 创建背景文档：`/tmp/claude-reports/AI-DEVELOPER-GUIDE-{timestamp}.md`
3. 验证文档包含核心内容（见 5.2）
4. 在task_context中引用该临时文件路径

**5.2 背景文档必须包含**

基础内容：
- 项目目录结构
- 现有代码位置（精确到文件路径）
- 可复用模块的使用示例
- 新增代码的放置位置

**关键内容**（⚠️ 必须包含）：
- **关联的 SPEC 文件引用**（完整路径 + 说明）
- **核心约束说明**（必须做什么、禁止做什么）
- **关键 SPEC 章节**（行号或章节名引用）
- **禁止行为清单**（明确的负面约束）

**5.3 背景文档模板**

参考模板：`~/.claude/skills/programmer/templates/AI-DEVELOPER-GUIDE-TEMPLATE.md`

**5.4 验证检查清单**

调用 AI-CLI 前必须验证：
- [ ] 临时背景文档存在：`/tmp/claude-reports/AI-DEVELOPER-GUIDE-*.md`
- [ ] 包含 SPEC 文件的完整路径引用
- [ ] 每个 SPEC 文件有说明（作用、关键章节）
- [ ] 核心约束明确列出（必须做什么）
- [ ] 禁止行为明确列出（不能做什么）
- [ ] 项目结构清晰（代码位置）

**⚠️ 禁止在项目目录创建背景文件**：
- ❌ 禁止：`SPEC/DOCS/AI-DEVELOPER-GUIDE.md`
- ❌ 禁止：项目根目录下任何 `*-GUIDE.md`、`*-REPORT.md`
- ✅ 正确：`/tmp/claude-reports/AI-DEVELOPER-GUIDE-{timestamp}.md`

**跳过的后果**：
- ❌ AI-CLI 会错误理解需求
- ❌ 产生大量错误代码（如本次案例：3500 行返工）
- ❌ 需要完全重写

### 步骤6：执行开发

**🚨 批处理优先原则**（参考原则3.5）：

```
┌─────────────────────────────────────────────────────────────────────────┐
│  同项目同角色的所有任务 = 一次AI CLI调用                                 │
│                                                                         │
│  CC理解：任务块1(REQ-001)、任务块2(REQ-002)、任务块3(REQ-003)...        │
│  AI CLI执行：一次调用 'REQ-001,REQ-002,REQ-003,...' 批量完成            │
└─────────────────────────────────────────────────────────────────────────┘
```

**执行方式**：

```bash
# ✅ 正确：批量执行同项目同角色的所有任务
Bash(command="ai-cli-runner.sh backend 'REQ-AUTH-001,REQ-AUTH-002,REQ-AUTH-003,REQ-USER-001' '实现所有后端功能' '$ctx'", timeout=43200000)

# ✅ 正确：不同角色可以并行（各自批量）
Bash(command="ai-cli-runner.sh frontend 'REQ-UI-001,REQ-UI-002,REQ-UI-003' '实现所有前端页面' '$ctx'", run_in_background=True, timeout=43200000)
Bash(command="ai-cli-runner.sh backend 'REQ-API-001,REQ-API-002,REQ-API-003' '实现所有后端API' '$ctx'", run_in_background=True, timeout=43200000)

# ❌ 错误：逐个调用同角色任务
Bash(command="ai-cli-runner.sh backend 'REQ-AUTH-001' '实现登录'")
Bash(command="ai-cli-runner.sh backend 'REQ-AUTH-002' '实现注册'")  # TOKEN浪费！
```

**task_context格式**（⚠️ 必须包含 SPEC 文件引用）：

```
【项目根目录】/home/putao/code/c-cpp/project/

【SPEC 文件引用】（⚠️ 强制，完整路径 + 说明）
- /完整路径/SPEC/01-REQUIREMENTS.md
  说明：功能需求定义（REQ-XXX）
  关键章节：所有需求条目

- /完整路径/SPEC/02-ARCHITECTURE.md
  说明：架构设计（ARCH-XXX）
  关键章节：模块划分、技术栈、数据流

- /完整路径/SPEC/05-RUST-IMPLEMENTATION.md
  说明：Rust 实现规范
  关键章节：
  - L11: 项目概述（纯 Rust 重写）
  - L332: ARCH-RUST-001（自实现 DEFLATE）
  - L95: ARCH-FFI-001（FFI 仅用于验证）

【核心约束】⚠️ 违反即失败
- 实现方式：纯 Rust 实现，禁止 FFI 用于生产代码
- FFI 用途：仅允许验证目录中使用
- 算法复刻：参考 C 代码但用 Rust 重写，不是包装器
- 验收标准：输出与 C 版本一致

【背景文档】/tmp/claude-reports/AI-DEVELOPER-GUIDE-{timestamp}.md
  说明：详细开发指南和约束说明（临时文件，任务完成后可删除）

【功能清单】（必须一次性完成，批量执行）
- REQ-AUTH-001：JWT认证中间件
- REQ-AUTH-002：用户登录API
- REQ-AUTH-003：用户注册API
- REQ-USER-001：用户信息查询

【代码复用】参考 src/middleware/base.py
【验收标准】所有功能完整实现，单测通过
```

**task_context 示例**：`~/.claude/skills/programmer/examples/task-context-example.md`

**等待规则**：
- 并发任务块（使用 `run_in_background=True`）→ 等待系统自动通知
- 单个任务块（前台执行）→ 直接等待任务完成
- 串行任务块 → 前一个完成后直接继续下一个

**🚨 重要：AI-CLI 执行期间的工作流程**：

```
┌─────────────────────────────────────────────────────────────────────────┐
│  AI-CLI 执行期间的正确工作流程                                           │
├─────────────────────────────────────────────────────────────────────────┤
│                                                                         │
│  ✅ 启动 AI-CLI 后                                                      │
│     └─▶ 停止主动监控进度（不要 tail/read 输出文件）                      │
│     └─▶ 不要轮询检查状态（BashOutput 禁止使用）                          │
│     └─▶ 等待系统自动通知（Background bash 有新输出时）                  │
│                                                                         │
│  ⏰ 系统通知时机                                                         │
│     └─▶ AI-CLI 完成时自动触发通知                                       │
│     └─▶ 此时再进行步骤 7（代码审查）                                    │
│                                                                         │
│  ❌ 禁止的行为                                                           │
│     └─▶ 启动后立即读取输出文件                                         │
│     └─▶ 定期轮询检查进度                                               │
│     └─▶ 主动查询"完成了吗"                                             │
│                                                                         │
└─────────────────────────────────────────────────────────────────────────┘
```

**原因**：
- AI-CLI 执行时间可能很长（数小时）
- 频繁读取输出浪费 TOKEN 和上下文
- 系统会在完成时自动通知
- 专注其他任务或等待即可

**禁止行为**：
- ❌ 同项目同角色任务逐个调用AI CLI（必须批量）
- ❌ 前台任务自动转换成后台模式
- ❌ 轮询检测任务状态（禁止 BashOutput 轮询）
- ❌ 任务块之间询问"是否继续"
- ❌ 启动后主动读取输出文件或监控进度

### 步骤7：代码审查

⚠️ 用户通知完成后执行，必须验证代码

> **审查依据**：代码审查必须遵循以下角色规范
> - `roles/debugger.md` - 调试分析规范（日志规范、错误处理、禁止模式）
> - `roles/quality.md` - 代码质量规范（SOLID原则、代码结构要求、命名规范）

**7.1 验证功能实现**

```bash
# 获取Issue任务清单
gh issue view <issue#> --json body,title
```

对每项功能：
- 使用 `git status` 和 `Read` 工具验证实现
- 检查是否符合SPEC定义
- 验证通过 → 标记完成
- 验证失败 → 记录问题，要求修复

**7.2 SPEC一致性验证**

```
[REQ-XXX] 需求名称
- 验收标准1: ✅/❌ [代码位置: file:line]
- 验收标准2: ✅/❌ [代码位置: file:line]

[ARCH-XXX] 架构约束
- 约束内容: [描述]
- 代码遵守: ✅/❌ [位置: file:line]
```

**7.3 代码质量审查（基于 quality.md）**

**检查项**：
- ✅ **可读性**：命名规范、函数长度<50行、嵌套深度<3层
- ✅ **可维护性**：遵循SOLID原则、模块耦合度低、依赖关系清晰
- ✅ **性能**：算法效率合理、无明显性能问题

**参考**：`roles/quality.md` 中的详细质量标准和检查清单

**7.4 调试规范审查（基于 debugger.md）**

**检查项**：
- ✅ **日志规范**：适当的日志记录、正确的日志级别（DEBUG/INFO/WARN/ERROR）
- ✅ **错误处理**：完整的错误处理、避免吞掉异常、有意义的错误信息
- ✅ **禁止模式**：无硬编码调试代码、无临时补丁式修复、无try-catch吞异常

**参考**：`roles/debugger.md` 中的调试原则和禁止行为

**7.5 决策**

| 结果 | 处理 |
|-----|------|
| 全部通过 | 进入步骤8 |
| 有问题 | 记录问题，要求AI CLI修复，重新审查 |

### 步骤8：自动提交和状态更新（🚨 强制执行步骤）

```
┌─────────────────────────────────────────────────────────────────────────┐
│  🚨 步骤8是强制执行步骤，步骤7通过后必须立即执行以下bash命令！          │
│                                                                         │
│  ❌ 禁止：步骤7完成后结束流程                                           │
│  ❌ 禁止：询问用户"是否提交"                                            │
│  ❌ 禁止：等待用户指示                                                  │
│  ✅ 必须：步骤7通过 → 立即执行步骤8的bash命令 → 报告完成                │
└─────────────────────────────────────────────────────────────────────────┘
```

**8.1 提交前检查**：
- 所有 `[REQ-XXX]` 验证项已完成
- 代码审查已通过
- 验证已通过

**8.2 立即执行代码提交（必须执行以下bash命令）**：

```bash
# 🚨 步骤7通过后，必须立即执行以下命令，不询问用户！

# 提取Issue号（优先使用步骤4创建的Issue，或自动检测）
ISSUE_NUMBER=$(gh issue list --limit 1 --search "sort:created-desc" --json number | jq -r '.[0].number')

# 执行提交脚本
~/.claude/scripts/commit-and-close.sh \
  --message "feat: 实现XXX功能 [REQ-XXX]" \
  --issue $ISSUE_NUMBER
```

**Bash工具调用方式**：
```
Bash(
  command="~/.claude/scripts/commit-and-close.sh --message 'feat: 实现XXX功能 [REQ-XXX]' --issue <issue#>",
  description="自动提交代码并关闭Issue"
)
```

**脚本功能**：
- 自动Issue检测（如果没提供会自动查找）
- 自动SPEC状态更新
- 版本号自动升级
- Git标签自动创建

**8.3 报告主会话**：

步骤8执行完成后，向主会话报告：
```
✅ 开发完成并已自动提交：
- 代码已验证并通过
- 提交已执行：[commit hash]
- Issue已关闭：#<issue#>
- SPEC状态已自动更新
```

```
┌─────────────────────────────────────────────────────────────────────────┐
│  🚨 执行检查清单（步骤7通过后逐项执行）                                  │
│                                                                         │
│  □ 执行 commit-and-close.sh 脚本                                       │
│  □ 确认提交成功（获取commit hash）                                      │
│  □ 确认Issue已关闭                                                      │
│  □ 向主会话报告完成结果                                                 │
│                                                                         │
│  只有全部完成后，programmer技能才算执行完毕！                            │
└─────────────────────────────────────────────────────────────────────────┘
```

---

## 错误调试流程

### 触发条件

- 代码审查发现问题
- 构建失败、运行时错误

### 调试步骤

1. **问题定位**：创建诊断脚本，复现问题
2. **根因分析**：分析日志、检查代码逻辑、验证数据结构
3. **制定方案**：明确修复策略和影响范围
4. **执行修复**：通过AI CLI执行修复
5. **验证修复**：确认修复有效
6. **回归验证**：确保没有破坏其他功能

### 数据结构对齐检测

**检测时机**：修改ORM模型后、验证失败涉及数据字段时

**检测内容**：
- 字段名称一致性
- 数据类型一致性
- 必填字段一致性
- 枚举值一致性
- 默认值一致性

---

## 快速参考

### 正确示例

```
✅ 任务块3已提交。继续实施任务块4：套餐订阅管理API...
   [直接开始工作]

✅ 发现SPEC中API-AUTH-003的响应格式不明确，需要确认：
   [使用AskUserQuestion询问]
```

### 错误示例

```
❌ 任务块3已完成。是否继续任务块4？还是先推送？
   [违反原则4：执行连续性]

❌ 先实现REQ-AUTH-001，完成后再实现REQ-AUTH-002
   [违反原则2：一次性完整交付]

❌ 这个功能比较复杂，我们分两个阶段实现
   [违反原则2：禁止分阶段]
```
