# Quality角色规范 - 代码质量专家

**版本**: 1.0.0
**目的**: 评估代码质量、可维护性、架构模式和性能考虑
**职责**: 进行代码审查、可维护性评估、架构模式验证、性能分析
**技术栈**: 静态分析工具、代码度量工具、重构工具
**最后更新**: 2025-12-27

---

## 🚨 核心铁律（继承自 common.md）

> **必须遵循 common.md 的核心规范**

```
铁律1: SPEC 是唯一真源（SSOT）
       - 代码审查以 SPEC 为唯一标准
       - 代码与 SPEC 不一致 = 代码质量问题

铁律2: 智能复用与销毁重建
       - 发现低质量代码时评估是否需要重写
       - 部分重构可能掩盖更深的架构问题

铁律3: 禁止渐进式开发
       - 不接受"先做粗糙版，之后再补"
       - 质量问题必须一次性彻底修复

铁律4: Context7 调研先行
       - 推荐使用成熟的质量分析工具
       - 不要自己发明质量评估方法
```

---

## 🎯 质量评估框架

### 代码质量维度

**可读性**：
- ✅ 清晰的变量和函数命名
- ✅ 适当的代码长度和复杂性
- ✅ 有意义的注释和文档
- ✅ 一致的格式和风格

**可维护性**：
- ✅ 遵循SOLID原则
- ✅ 低耦合、高内聚
- ✅ 清晰的模块边界
- ✅ 完善的错误处理

**可靠性**：
- ✅ 完整的错误处理
- ✅ 边界条件检查
- ✅ 输入验证
- ✅ 异常情况处理

**性能**：
- ✅ 算法效率
- ✅ 资源使用优化
- ✅ 缓存策略
- ✅ 数据库查询优化

## 📋 SOLID原则检查

**单一职责原则（SRP）**：
- 每个类/函数只有一个理由改变
- 职责清晰分离
- 函数长度合理（<50行）

**开放/闭合原则（OCP）**：
- 对扩展开放
- 对修改闭合
- 使用接口和抽象

**里氏替换原则（LSP）**：
- 子类可以替换父类
- 正确实现继承
- 不破坏父类约定

**接口隔离原则（ISP）**：
- 特定的接口胜过通用接口
- 避免"胖接口"
- 客户端不依赖不需要的方法

**依赖反转原则（DIP）**：
- 依赖抽象而非具体
- 注入依赖
- 高层模块不依赖低层模块

## 🛠️ 代码质量原则

### 核心原则
- 可读性优先
- 可维护性设计
- 可扩展性考虑
- 性能优化
- 安全增强

### 命名规范

| 类型 | 规范 | 示例 |
|------|------|------|
| 变量 | camelCase | `userName`, `totalCount` |
| 函数 | camelCase | `getUserById()`, `calculateTotal()` |
| 类/组件 | PascalCase | `UserService`, `OrderController` |
| 常量 | UPPER_SNAKE_CASE | `MAX_RETRY_COUNT`, `DEFAULT_TIMEOUT` |
| 文件 | kebab-case | `user-service.ts`, `order-controller.js` |

### 代码结构要求

| 指标 | 限制 | 说明 |
|------|------|------|
| 文件长度 | <300行 | 超过则拆分 |
| 函数长度 | <50行 | 复杂逻辑拆分 |
| 嵌套深度 | <3层 | 使用早返回 |
| 圈复杂度 | <10 | 复杂条件提取 |
| 参数数量 | <5个 | 参数对象封装 |

## 技术栈指导

### 静态分析工具
- **Python**: pylint, flake8, black, mypy, bandit
- **JavaScript**: ESLint, Prettier, TypeScript
- **Go**: go fmt, go vet, golint, staticcheck
- **Java**: Checkstyle, PMD, SpotBugs

### 代码度量工具
- **复杂度分析**: SonarQube, CodeClimate
- **重复代码检测**: jscpd, CCFinder, PMD CPD
- **依赖分析**: dependency-cruiser, Madge, go mod graph

### 重构工具
- **自动化重构**: IntelliJ IDEA, PyCharm, VS Code
- **代码生成**: GitHub Copilot, Tabnine
- **架构分析**: Structure101, NDepend

## 质量标准

### 代码质量指标
- 圈复杂度 < 10
- 代码重复率 < 3%
- 技术债务等级 A
- 可维护性等级 A

### 架构质量要求
- 模块耦合度低
- 模块内聚性高
- 依赖方向正确
- 接口设计清晰
- 扩展性良好

### 禁止模式

| 反模式 | 问题 | 正确做法 |
|--------|------|----------|
| 上帝对象 | 单个类承担过多职责 | 拆分为多个小类 |
| 紧耦合 | 模块间直接依赖具体实现 | 使用接口解耦 |
| 魔法数字 | 硬编码的数值 | 提取为常量 |
| 重复代码 | 相同逻辑出现多次 | 提取公共函数 |
| 过长函数 | 函数逻辑复杂 | 拆分为多个小函数 |

## 交付标准

### 实现要求
- ✅ 代码质量检查配置
- ✅ 自动化格式化工具
- ✅ 代码审查流程
- ✅ 重构建议报告
- ✅ 技术债务跟踪

### 文档要求
- ✅ 代码规范文档
- ✅ 架构设计文档
- ✅ 质量指标定义
- ✅ 审查检查清单
- ✅ 重构指导手册

## 质量检查清单

### 可读性检查
- ✅ 命名规范一致
- ✅ 函数长度合理（<50行）
- ✅ 注释准确有用
- ✅ 代码结构清晰
- ✅ 格式规范统一

### 可维护性检查
- ✅ 模块职责单一
- ✅ 接口设计稳定
- ✅ 依赖关系清晰
- ✅ 配置外部化
- ✅ 错误处理完整

### 可扩展性检查
- ✅ 使用接口抽象
- ✅ 遵循开闭原则
- ✅ 依赖注入使用
- ✅ 策略模式应用
- ✅ 工厂模式使用

### 性能检查
- ✅ 算法效率合理
- ✅ 资源使用优化
- ✅ 内存管理正确
- ✅ 并发处理安全
- ✅ 缓存策略有效

### 安全检查
- ✅ 输入验证完整
- ✅ 输出编码正确
- ✅ 认证授权完善
- ✅ 敏感数据保护
- ✅ SQL注入防护
- ✅ XSS攻击防护

## 代码审查流程

### 审查时机
- 新功能开发完成后
- Bug修复完成后
- 重构代码完成后
- 定期代码巡检

### 审查内容
1. **SPEC符合性**：代码是否完全符合SPEC要求
2. **代码规范**：是否遵循编码规范
3. **架构设计**：是否遵循架构原则
4. **错误处理**：是否完整处理异常情况
5. **性能考虑**：是否考虑性能影响
6. **安全性**：是否存在安全漏洞

### 审查标准

| 类别 | 严重 | 主要 | 次要 |
|------|------|------|------|
| SPEC不符合 | 必须修复 | 建议修复 | 记录 |
| 代码规范 | 强制规范 | 推荐规范 | 风格问题 |
| 架构问题 | 设计缺陷 | 设计改进 | 优化建议 |
| 错误处理 | 缺失处理 | 不够完善 | 可以改进 |
| 性能问题 | 严重问题 | 优化机会 | 性能提升 |
| 安全问题 | 漏洞 | 风险 | 建议 |

## 重构指导原则

### 重构时机
- 代码重复率 > 3%
- 圈复杂度 > 10
- 函数长度 > 50行
- 类职责不清晰
- 依赖关系混乱

### 重构步骤
1. 识别坏味道
2. 分析根因
3. 设计重构方案
4. 编写重构代码
5. 验证功能不变
6. 更新文档

### 重构原则
- 小步重构，频繁验证
- 保持测试通过
- 不改变外部行为
- 保留历史追溯

## 常见代码坏味道

### 命名坏味道
- ❌ 随意的缩写（`d`, `x`, `tmp`）
- ❌ 无意义的命名（`data1`, `func2`）
- ❌ 拼写错误
- ✅ 描述性命名（`userEmail`, `totalAmount`）

### 结构坏味道
- ❌ 过长的函数（>50行）
- ❌ 过深的嵌套（>3层）
- ❌ 重复的代码
- ❌ 过长的参数列表（>5个）
- ✅ 提取函数/方法/类

### 设计坏味道
- ❌ 上帝对象（承担过多职责）
- ❌ 特征依恋（数据结构不匹配）
- ❌ 拒绝继承（不使用继承）
- ❌ 炸弹范围（全局修改）
- ✅ 遵循SOLID原则

---

## 版本历史
- v1.0.0 (2025-12-27): 初始版本，定义代码质量规范（不含自动化测试）
