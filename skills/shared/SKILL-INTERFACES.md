# 技能接口规范文档

> **版本**：v1.0
> **日期**：2025-12-25
> **适用范围**：architect、programmer等所有AI技能

---

## 1. 核心设计理念

### 1.1 用户中心原则

```
┌─────────────────────────────────────────────────────────────────────────┐
│  用户是绝对中心，技能是响应式工具                                        │
│                                                                         │
│  ✅ 正确理解：                                                           │
│     - 用户随时决定调用哪个技能                                           │
│     - 技能根据上下文响应，不预设流程                                     │
│     - 4个审核点是保护机制，不是流程节点                                 │
│                                                                         │
│  ❌ 错误理解：                                                           │
│     - 必须按 architect → programmer 顺序调用                           │
│     - 技能间有固定调用顺序                                               │
│     - 状态机控制技能调用                                                 │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.2 技能独立性

每个技能都是独立的模块，具有：
- 明确的职责边界
- 独立的输入/输出接口
- 自包含的上下文管理
- 不依赖其他技能的调用顺序

### 1.3 状态机上下文管理

状态机不是技能调用控制器，而是：
- 审核点触发条件的判断器
- 自动化流程的协调器
- REQ-XXX标签状态的管理器

---

## 2. 技能调用触发条件

### 2.1 主会话决策流程（强制执行）

```
用户消息
    ↓
步骤1：判断是否涉及需求/设计变更
  以下情况 = 需求变更 = 必须调用 /architect：
  - 用户说"改成XXX"、"支持XXX"、"不要XXX"
  - 用户调整功能参数、接口、行为
  - 用户修改技术方案、架构决策
  - 任何导致SPEC内容需要变化的指令
  → 立即调用 /architect，禁止口头调整计划
    ↓ 否
步骤2：判断是否涉及代码实现
  以下情况 = 必须调用 /programmer：
  - 用户说"继续"、"开始实现"、"写代码"
  - 计划确认后的代码开发
  - Bug修复、功能修改
  → 立即调用 /programmer，禁止自己写代码
    ↓ 否
步骤3：主会话直接处理（仅限以下情况）
  - 纯文档（README、注释）
  - 配置值修改
  - 格式调整
  - 回答问题
```

### 2.2 技能调用决策树

```
用户请求类型
    ↓
代码修改类 → /programmer
    ├─ 功能实现
    ├─ Bug修复
    └─ 代码重构

架构设计类 → /architect
    ├─ 需求变更
    ├─ 技术选型
    ├─ 架构调整
    └─ SPEC更新
```

### 2.3 Context传递规范

```
每个技能调用必须包含完整上下文：

【项目根目录】
完整路径

【关联文件引用】
- SPEC文件路径 + 说明
- 关键章节引用
- 核心约束说明

【任务背景】
- 用户原始需求
- 当前项目状态
- 已有代码/模块

【执行要求】
- 必须做什么
- 禁止做什么
- 验收标准

【临时文件】
- AI-DEVELOPER-GUIDE路径（如适用）
```

---

## 3. 审核点触发机制

### 3.1 审核点通用规范

- **触发判断**：基于状态和上下文，不基于技能
- **执行者**：当前被调用技能负责判断并触发
- **询问方式**：使用标准AskUserQuestion格式
- **自动记录**：审核结果自动记录到Issue和SPEC标签

### 3.2 审核点触发条件详解

#### 审核点1：SPEC进入开发
- **触发条件**：存在完整SPEC，准备开始代码开发
- **判断技能**：architect（设计完成）或programmer（已有SPEC）
- **不触发场景**：Bug修复、代码审查、部分功能实现

#### 审核点2：实施计划确认
- **触发条件**：从分析SPEC进入代码实施阶段
- **判断技能**：programmer（读取SPEC后准备开发）
- **不触发场景**：Bug修复（直接进入修复流程）

---

## 4. 技能间协作机制

### 4.1 自动化协作（无需人工）

```
Bug修复流程：
发现问题 → 自动生成Issue
↓
programmer接收Bug → 自动分析修复 → 提交代码 → 关闭Issue → 更新标签"✅ 已修复"
```

### 4.2 Issue生命周期管理

```
Issue创建时机：
- 计划确认后（programmer创建）
- Bug发现时（programmer创建）
- 需求变更时（architect创建）

Issue状态流转：
open → in_progress → resolved/closed
  ↓        ↓          ↓
开发中   修复中      已完成

标签关联：
每个Issue自动关联REQ-XXX标签
标签状态随Issue变化
```

### 4.3 SPEC状态同步

```
REQ-XXX标签自动更新流程：
"✅ SPEC完整" → "✅ 已实现"

触发条件：
- architect完成 → 追加"✅ SPEC完整"
- programmer提交 → 追加"✅ 已实现 (commit: xxx)"
```

---

## 5. 错误处理与恢复

### 5.1 技能调用错误

```
技能调用失败处理：
1. 参数错误 → 主会话重新分析，纠正参数后重试
2. 上下文缺失 → 要求用户提供完整信息
3. 网络超时 → 重试，多次失败报告用户
4. AI CLI错误 → 记录错误，提供诊断信息
```

### 5.2 审核点处理错误

```
用户响应异常处理：
1. 不在选项内 → 提示重新选择，限制次数3次
2. 超时未响应 → 默认选择最安全选项（通常是"调整方案"）
3. 矛盾选择 → 指出矛盾，要求澄清
```

### 5.3 自动化流程错误

```
错误处理：
- AI CLI修复失败 → 记录错误，通知用户介入
```

---

## 6. 输入输出接口规范

### 6.1 标准输入格式

```json
{
  "session_context": {
    "project_root": "/path/to/project",
    "spec_files": [
      {
        "path": "SPEC/01-REQUIREMENTS.md",
        "description": "功能需求定义",
        "key_sections": ["REQ-AUTH-001", "REQ-AUTH-002"]
      }
    ],
    "constraints": {
      "must_do": ["列表"],
      "forbidden": ["列表"]
    }
  },
  "user_request": "用户原始请求",
  "additional_context": {}
}
```

### 6.2 标准输出格式

```json
{
  "status": "success|error|needs_review",
  "result": {
    "output": "执行结果",
    "files_created": ["path1", "path2"],
    "issues_created": ["#123"],
    "labels_updated": ["REQ-XXX: 新状态"]
  },
  "next_steps": [
    "下一步操作建议"
  ],
  "needs_review": {
    "review_point": 1-4,
    "question": "询问内容",
    "options": ["选项1", "选项2"]
  }
}
```

### 6.3 错误输出格式

```json
{
  "status": "error",
  "error_type": "parameter|context|execution|network",
  "error_message": "详细错误信息",
  "suggestion": "修复建议",
  "recovery_steps": ["步骤1", "步骤2"]
}
```

---

## 7. 性能与约束

### 7.1 超时设置

| 操作类型 | 默认超时 | 可配置 |
|----------|----------|--------|
| skill调用 | 12小时 | 是 |
| 单个AI CLI | 4小时 | 是 |
| 审核点响应 | 5分钟 | 否 |

### 7.2 资源限制

- 内存使用：单次对话 < 8GB
- 文件操作：临时文件 < 1GB
- 并发任务：同一项目最多3个
- Issue数量：单次会话 < 50个

### 7.3 重试机制

| 错误类型 | 重试次数 | 重试策略 |
|----------|----------|----------|
| 网络错误 | 3次 | 指数退避 |
| API限制 | 5次 | 线性间隔 |
| 参数错误 | 1次 | 不重试 |
| AI CLI错误 | 2次 | 立即重试 |

---

## 8. 版本兼容性

### 8.1 向后兼容

- 技能接口保持向后兼容
- 新版本支持旧版本输入格式
- 重大变更通过版本号标识

### 8.2 废弃策略

- 废弃功能提前6个月通知
- 提供迁移指南
- 旧版本支持至少3个月

---

*本文档是技能协作的基础规范，所有技能实现必须遵循本文档定义的接口和协作机制。*

## 版本历史
- v1.0 (2025-12-25): 初始版本，定义用户驱动的技能协作接口规范