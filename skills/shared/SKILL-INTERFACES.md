# 技能接口规范文档

> **版本**：v1.1
> **日期**：2025-12-26
> **适用范围**：architect、programmer等所有AI技能
> **更新内容**：实施平衡型自动化审核点机制（减少人工干预，保留安全保障）

---

## 1. 核心设计理念

### 1.1 用户中心原则

```
┌─────────────────────────────────────────────────────────────────────────┐
│  用户是绝对中心，技能是响应式工具                                        │
│                                                                         │
│  ✅ 正确理解：                                                           │
│     - 用户随时决定调用哪个技能                                           │
│     - 技能根据上下文响应，不预设流程                                     │
│     - 平衡型自动化：效率与安全的平衡                                     │
│     - 简单任务自动通过，复杂任务保留审核                                 │
│                                                                         │
│  ❌ 错误理解：                                                           │
│     - 必须按 architect → programmer 顺序调用                           │
│     - 技能间有固定调用顺序                                               │
│     - 状态机控制技能调用                                                 │
│     - 所有任务都需要人工审核                                             │
└─────────────────────────────────────────────────────────────────────────┘
```

### 1.4 平衡型自动化策略

**核心原则**：在保证代码质量的前提下，最大化自动化程度

| 审核点 | 原机制 | 平衡型机制 |
|--------|--------|-----------|
| **审核点1** | 用户确认SPEC完整 | ✅ **自动验证**（门禁C1）+ ❌失败时询问 |
| **审核点2** | 所有任务需用户确认 | ✅ **简单任务自动通过** + 复杂任务保留确认 |
| **审核点4** | 用户确认Bug分类 | ✅ **自动分类**（基于失败规则） |

**简单任务判断标准**：
- Bug修复（关联Issue + 影响范围<3个文件）
- 文档更新（仅修改`.md`文件）
- 配置调整（仅修改配置文件）
- 小改动（文件变更<3个 + 无架构影响）

**复杂功能判断标准**：
- 新功能实现（REQ-XXX涉及多个模块）
- 代码重构（修改>5个文件或核心模块）
- 架构变更（涉及ARCH-XXX）
- 跨服务修改（影响多个项目）

**用户手动审查机制**：
- 新增 `/programmer --review` 命令
- 用户可随时触发代码审查
- 验证代码与SPEC的一致性
- 生成质量报告和改进建议

### 1.2 技能独立性

每个技能都是独立的模块，具有：
- 明确的职责边界
- 独立的输入/输出接口
- 自包含的上下文管理
- 不依赖其他技能的调用顺序

### 1.3 状态机上下文管理

状态机不是技能调用控制器，而是：
- 审核点触发条件的判断器
- 自动化流程的协调器
- REQ-XXX标签状态的管理器

---

## 2. 技能调用触发条件

### 2.1 主会话决策流程（强制执行）

```
用户消息
    ↓
步骤1：判断是否涉及需求/设计变更
  以下情况 = 需求变更 = 必须调用 /architect：
  - 用户说"改成XXX"、"支持XXX"、"不要XXX"
  - 用户调整功能参数、接口、行为
  - 用户修改技术方案、架构决策
  - 任何导致SPEC内容需要变化的指令
  → 立即调用 /architect，禁止口头调整计划
    ↓ 否
步骤2：判断是否涉及代码实现
  以下情况 = 必须调用 /programmer：
  - 用户说"继续"、"开始实现"、"写代码"
  - 计划确认后的代码开发
  - Bug修复、功能修改
  → 立即调用 /programmer，禁止自己写代码
    ↓ 否
步骤3：主会话直接处理（仅限以下情况）
  - 纯文档（README、注释）
  - 配置值修改
  - 格式调整
  - 回答问题
```

### 2.2 技能调用决策树

```
用户请求类型
    ↓
代码修改类 → /programmer
    ├─ 功能实现
    ├─ Bug修复
    └─ 代码重构

架构设计类 → /architect
    ├─ 需求变更
    ├─ 技术选型
    ├─ 架构调整
    └─ SPEC更新
```

### 2.3 Context传递规范

```
每个技能调用必须包含完整上下文：

【项目根目录】
完整路径

【关联文件引用】
- SPEC文件路径 + 说明
- 关键章节引用
- 核心约束说明

【任务背景】
- 用户原始需求
- 当前项目状态
- 已有代码/模块

【执行要求】
- 必须做什么
- 禁止做什么
- 验收标准

【临时文件】
- AI-DEVELOPER-GUIDE路径（如适用）
```

---

## 3. 平衡型审核点触发机制

### 3.1 审核点通用规范

- **触发判断**：基于状态和上下文，自动评估任务复杂度
- **执行者**：当前被调用技能负责判断并执行
- **询问方式**：复杂任务使用AskUserQuestion，简单任务自动通过
- **自动记录**：审核结果自动记录到Issue和SPEC标签

### 3.2 审核点1：SPEC完整性验证（自动）

**平衡型优化**：完全自动化，仅在失败时询问

#### 门禁C1：SPEC完整性自动检查

**检查项**：
- ✅ 需求完整：所有REQ-XXX有明确验收标准
- ✅ 架构完整：模块划分、技术栈、数据流已定义
- ✅ 数据完整：表结构、字段、关系、索引已定义
- ✅ API完整：接口格式、错误码已定义

**触发时机**：architect完成设计后

**自动执行逻辑**：
```python
if SPEC完整性检查通过:
    自动追加标签 "✅ SPEC完整 (YYYY-MM-DD)"
    允许直接进入开发阶段（无需用户确认）
else:
    向用户报告缺失内容清单
    等待用户决策：
    - 调用architect补充SPEC
    - 或强制继续（风险提示）
```

**不触发场景**：Bug修复、代码审查、小改动

### 3.3 审核点2：实施计划确认（条件自动化）

**平衡型优化**：简单任务自动通过，复杂功能保留确认

#### 任务复杂度自动判断

| 判断维度 | 简单任务 | 复杂功能 |
|---------|---------|----------|
| **任务类型** | Bug修复、文档更新、配置调整 | 新功能、重构、架构变更 |
| **影响范围** | < 3个文件 | ≥ 3个文件 |
| **SPEC影响** | 无REQ-XXX变更 | 涉及REQ-XXX |
| **架构影响** | 无 | 涉及ARCH-XXX |
| **跨服务影响** | 单项目 | 多项目 |

#### 简单任务：自动通过流程

**判断条件**（满足任一即可）：
1. Bug修复（关联Issue + 影响范围<3个文件）
2. 文档更新（仅修改`.md`文件）
3. 配置调整（仅修改配置文件）
4. 小改动（文件变更<3个 + 无架构影响）

**自动执行流程**：
```python
if 判断为简单任务():
    展示简化版实施计划（1屏内）
    追加说明："🤖 简单任务，自动通过审核点2"
    直接继续执行步骤4-8（无需等待确认）
```

#### 复杂功能：保留确认流程

**判断条件**（满足任一即可）：
1. 新功能实现（REQ-XXX涉及多个模块）
2. 代码重构（修改>5个文件或核心模块）
3. 架构变更（涉及ARCH-XXX）
4. 跨服务修改（影响多个项目）

**保留确认流程**：
```python
if 判断为复杂功能():
    展示详细实施计划
    包含：SPEC理解摘要、任务块划分、完整功能清单
    ⏸️ 等待用户明确确认
    确认后继续步骤4-8
```

### 3.4 审核点4：Bug分类处理（自动）

**平衡型优化**：基于失败规则自动分类和处理

#### 测试失败自动分类规则

| 失败类型 | 测试层 | 自动分类 | 自动处理 |
|---------|--------|----------|----------|
| 代码逻辑错误 | 单元测试 | 代码Bug | 自动调用programmer修复 |
| 接口不符合 | 集成测试 | API契约问题 | 自动调用programmer修复 |
| SPEC不符合 | E2E测试 | SPEC冲突 | **询问用户**决策 |
| 环境问题 | 任意 | 非代码问题 | 自动重试，失败报告 |

**自动执行逻辑**：
```python
# 测试失败自动分类
if 测试类型 == "单元测试":
    Bug类型 = "代码逻辑错误"
    处理方式 = "自动调用programmer修复"
elif 测试类型 == "集成测试" and 失败原因包含接口:
    Bug类型 = "API契约不符合"
    处理方式 = "自动调用programmer修复"
elif 测试类型 == "E2E测试" and 失败原因包含SPEC不符合:
    Bug类型 = "SPEC冲突"
    处理方式 = "报告用户，等待决策"
    询问内容：
    1. 调用architect更新SPEC
    2. 调用programmer修改代码符合SPEC
    3. 强制通过（标记技术债）
elif 测试类型 == "环境问题":
    处理方式 = "自动重试最多3次，失败后报告用户"
```

### 3.5 安全网机制（完全保留）

以下检查**完全保留**，确保自动化不会降低代码质量：

| 安全检查 | 触发时机 | 行为 |
|---------|---------|------|
| **Pre-commit Hook** | git commit | 敏感文件阻止，其他警告 |
| **门禁C1** | architect完成 | SPEC完整性自动验证 |
| **门禁C2** | programmer步骤7 | 代码质量自动审查 |
| **门禁C3** | testing步骤0 | 测试覆盖率自动检查 |

---

## 4. 技能间协作机制

### 4.1 自动化协作（无需人工）

```
Bug修复流程：
发现问题 → 自动生成Issue
↓
programmer接收Bug → 自动分析修复 → 提交代码 → 关闭Issue → 更新标签"✅ 已修复"
```

### 4.2 Issue生命周期管理

```
Issue创建时机：
- 计划确认后（programmer创建）
- Bug发现时（programmer创建）
- 需求变更时（architect创建）

Issue状态流转：
open → in_progress → resolved/closed
  ↓        ↓          ↓
开发中   修复中      已完成

标签关联：
每个Issue自动关联REQ-XXX标签
标签状态随Issue变化
```

### 4.3 SPEC状态同步

```
REQ-XXX标签自动更新流程：
"✅ SPEC完整" → "✅ 已实现"

触发条件：
- architect完成 → 追加"✅ SPEC完整"
- programmer提交 → 追加"✅ 已实现 (commit: xxx)"
```

---

## 5. 错误处理与恢复

### 5.1 技能调用错误

```
技能调用失败处理：
1. 参数错误 → 主会话重新分析，纠正参数后重试
2. 上下文缺失 → 要求用户提供完整信息
3. 网络超时 → 重试，多次失败报告用户
4. AI CLI错误 → 记录错误，提供诊断信息
```

### 5.2 审核点处理错误

```
用户响应异常处理：
1. 不在选项内 → 提示重新选择，限制次数3次
2. 超时未响应 → 默认选择最安全选项（通常是"调整方案"）
3. 矛盾选择 → 指出矛盾，要求澄清
```

### 5.3 自动化流程错误

```
错误处理：
- AI CLI修复失败 → 记录错误，通知用户介入
```

---

## 6. 输入输出接口规范

### 6.1 标准输入格式

```json
{
  "session_context": {
    "project_root": "/path/to/project",
    "spec_files": [
      {
        "path": "SPEC/01-REQUIREMENTS.md",
        "description": "功能需求定义",
        "key_sections": ["REQ-AUTH-001", "REQ-AUTH-002"]
      }
    ],
    "constraints": {
      "must_do": ["列表"],
      "forbidden": ["列表"]
    }
  },
  "user_request": "用户原始请求",
  "additional_context": {}
}
```

### 6.2 标准输出格式

```json
{
  "status": "success|error|needs_review",
  "result": {
    "output": "执行结果",
    "files_created": ["path1", "path2"],
    "issues_created": ["#123"],
    "labels_updated": ["REQ-XXX: 新状态"]
  },
  "next_steps": [
    "下一步操作建议"
  ],
  "needs_review": {
    "review_point": 1-4,
    "question": "询问内容",
    "options": ["选项1", "选项2"]
  }
}
```

### 6.3 错误输出格式

```json
{
  "status": "error",
  "error_type": "parameter|context|execution|network",
  "error_message": "详细错误信息",
  "suggestion": "修复建议",
  "recovery_steps": ["步骤1", "步骤2"]
}
```

---

## 7. 性能与约束

### 7.1 超时设置

| 操作类型 | 默认超时 | 可配置 |
|----------|----------|--------|
| skill调用 | 12小时 | 是 |
| 单个AI CLI | 4小时 | 是 |
| 审核点响应 | 5分钟 | 否 |

### 7.2 资源限制

- 内存使用：单次对话 < 8GB
- 文件操作：临时文件 < 1GB
- 并发任务：同一项目最多3个
- Issue数量：单次会话 < 50个

### 7.3 重试机制

| 错误类型 | 重试次数 | 重试策略 |
|----------|----------|----------|
| 网络错误 | 3次 | 指数退避 |
| API限制 | 5次 | 线性间隔 |
| 参数错误 | 1次 | 不重试 |
| AI CLI错误 | 2次 | 立即重试 |

---

## 8. 版本兼容性

### 8.1 向后兼容

- 技能接口保持向后兼容
- 新版本支持旧版本输入格式
- 重大变更通过版本号标识

### 8.2 废弃策略

- 废弃功能提前6个月通知
- 提供迁移指南
- 旧版本支持至少3个月

---

*本文档是技能协作的基础规范，所有技能实现必须遵循本文档定义的接口和协作机制。*

## 版本历史
- v1.1 (2025-12-26): 实施平衡型自动化审核点机制，减少人工干预保留安全保障
- v1.0 (2025-12-25): 初始版本，定义用户驱动的技能协作接口规范